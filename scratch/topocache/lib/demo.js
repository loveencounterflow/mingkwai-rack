// Generated by CoffeeScript 1.10.0
(function() {
  var CND, FS, LTSORT, TC, XXX, badge, debug, echo, help, info, log, main, rpr, step, test, urge, warn, whisper,
    slice = [].slice;

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'TOPOCACHE/DEMO';

  log = CND.get_logger('plain', badge);

  debug = CND.get_logger('debug', badge);

  info = CND.get_logger('info', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  whisper = CND.get_logger('whisper', badge);

  echo = CND.echo.bind(CND);

  test = require('guy-test');

  TC = require('./main');

  LTSORT = require('ltsort');

  step = require('coffeenode-suspend').step;

  FS = {};

  FS._t = 1000;

  FS.cache = {};

  FS._now = function() {
    return this._t += +1;
  };

  FS.write = function(name, value) {
    var t;
    t = this._now();
    this.cache[name] = {
      t: t,
      value: value
    };
    return value;
  };

  FS.read = function(name) {
    var R;
    if ((R = FS.cache[name]) == null) {
      return void 0;
    }
    return R.value;
  };

  FS.read_json = function(name) {
    return JSON.parse(this.read(name));
  };

  FS.write_json = function(name, value) {
    return this.write(name, JSON.stringify(value));
  };

  FS.fetch_cache = function(handler) {
    setImmediate((function(_this) {
      return function() {
        return handler(null, _this.cache);
      };
    })(this));
    return null;
  };

  XXX = {};

  XXX.cmp = function(name_a, name_b) {
    var entry_a, entry_b;
    if ((entry_a = FS.cache[name_a]) == null) {
      throw new Error("unknown name " + (rpr(name_a)));
    }
    if ((entry_b = FS.cache[name_b]) == null) {
      throw new Error("unknown name " + (rpr(name_b)));
    }
    if (entry_a.t < entry_b.t) {
      return -1;
    }
    if (entry_a.t > entry_b.t) {
      return +1;
    }
    return 0;
  };

  XXX.test_cromulence = function() {
    var comparator, comparators, i, len, reference;
    reference = arguments[0], comparators = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    if (!(comparators.length > 0)) {
      throw new Error("need at least one comparator, got none");
    }
    for (i = 0, len = comparators.length; i < len; i++) {
      comparator = comparators[i];
      if ((this.cmp(reference, comparator)) < 0) {
        return false;
      }
    }
    return true;
  };

  this.new_cache = function() {
    var R;
    R = {
      '~isa': 'TOPOCACHE/cache',
      'graph': LTSORT.new_graph({
        loners: false
      }),
      'fixes': {}
    };
    return this._reset_chart(this._reset_trend(R));
  };

  this._reset_chart = function(me) {
    me['boxed-chart'] = null;
    me['indexed-chart'] = null;
    return me;
  };

  this._reset_trend = function(me) {
    me['boxed-trend'] = null;
    me['indexed-trend'] = null;
    return me;
  };

  this.register = function(me, precedent, consequent, fix) {
    var rc_key;
    rc_key = this._get_rc_key(me, precedent, consequent);
    me['fixes'][rc_key] = fix;
    LTSORT.add(me['graph'], precedent, consequent);
    return this._reset_chart(me);
  };

  this._get_rc_key = function(me, precedent, consequent) {
    return consequent + " -> " + precedent;
  };

  this.get_fix = function(me, precedent, consequent, fallback) {
    var R, rc_key;
    rc_key = this._get_rc_key(me, precedent, consequent);
    if ((R = me['fixes'][rc_key]) == null) {
      if (fallback === void 0) {
        throw new Error("no fix for " + (rpr(rc_key)));
      }
      R = fallback;
    }
    return R;
  };

  this.get_boxed_chart = function(me) {
    var R;
    if ((R = me['boxed-chart']) != null) {
      return R;
    }
    LTSORT.linearize(me['graph']);
    return me['boxed-chart'] = LTSORT.group(me['graph']);
  };

  this.get_indexed_chart = function(me) {
    var R;
    if ((R = me['indexed-chart']) != null) {
      return R;
    }
    return me['indexed-chart'] = this._indexed_from_boxed_series(me, this.get_boxed_chart(me));
  };

  this.fetch_boxed_trend = function(me, handler) {

    /* TAINT relies on FS */
    var Z;
    if ((Z = me['boxed-trend']) != null) {
      setImmediate(function() {
        return handler(null, Z);
      });
      return null;
    }
    step((function(_this) {
      return function*(resume) {
        var cache_entries, collector, entry, i, len, name, name1, ref, t;
        Z = [];
        collector = {};
        cache_entries = (yield FS.fetch_cache(resume));
        for (name in cache_entries) {
          entry = cache_entries[name];
          (collector[name1 = entry.t] != null ? collector[name1] : collector[name1] = []).push(name);
        }
        ref = (Object.keys(collector)).sort();
        for (i = 0, len = ref.length; i < len; i++) {
          t = ref[i];
          Z.push(collector[t]);
        }
        return handler(null, me['boxed-trend'] = Z);
      };
    })(this));
    return null;
  };

  this.fetch_indexed_trend = function(me, handler) {
    var Z;
    if ((Z = me['indexed-trend']) != null) {
      setImmediate(function() {
        return handler(null, Z);
      });
      return null;
    }
    step((function(_this) {
      return function*(resume) {
        var boxed_trend;
        boxed_trend = (yield _this.fetch_boxed_trend(me, resume));
        Z = me['indexed-trend'] = _this._indexed_from_boxed_series(me, boxed_trend);
        return handler(null, Z);
      };
    })(this));
    return null;
  };

  this._indexed_from_boxed_series = function(me, boxed_series) {
    var R, box, box_idx, i, j, len, len1, name;
    R = {};
    for (box_idx = i = 0, len = boxed_series.length; i < len; box_idx = ++i) {
      box = boxed_series[box_idx];
      for (j = 0, len1 = box.length; j < len1; j++) {
        name = box[j];
        R[name] = box_idx;
      }
    }
    return R;
  };

  this.find_first_fault = function(me, handler) {
    return this._find_faults(me, true, handler);
  };

  this.find_faults = function(me, handler) {
    return this._find_faults(me, false, handler);
  };

  this._find_faults = function(me, first_only, handler) {
    step((function(_this) {
      return function*(resume) {
        var R, cmp_charting_idx, cmp_name, cmp_trending_idx, entry, indexed_chart, indexed_trend, messages, ref_charting_idx, ref_name, ref_trending_idx, warn_missing;
        _this._reset_trend(me);
        indexed_chart = _this.get_indexed_chart(me);
        indexed_trend = (yield _this.fetch_indexed_trend(me, resume));
        R = first_only ? null : [];
        messages = {};
        warn_missing = function(name) {

          /* TAINT warn or fail? */
          var message;
          message = "not in trend: " + (rpr(ref_name));
          if (!(message in messages)) {
            warn(message);
          }
          messages[message] = 1;
          return null;
        };
        for (ref_name in indexed_chart) {
          ref_charting_idx = indexed_chart[ref_name];
          if ((ref_trending_idx = indexed_trend[ref_name]) == null) {
            warn_missing(ref_name);
            continue;
          }
          for (cmp_name in indexed_chart) {
            cmp_charting_idx = indexed_chart[cmp_name];

            /* Skip entries that have the same or smaller charting index (that are not depenedent on
            reference):
             */
            if (ref_charting_idx <= cmp_charting_idx) {
              continue;
            }
            if ((cmp_trending_idx = indexed_trend[cmp_name]) == null) {
              warn_missing(cmp_name);
              continue;
            }

            /* A fault is indicated by the trending index being in violation of the dependency relation
            as expressed by the charting index:
             */
            if (!(ref_trending_idx > cmp_trending_idx)) {
              entry = {
                reference: ref_name,
                comparison: cmp_name,
                fix: TC.get_fix(me, cmp_name, ref_name, null)
              };
              if (first_only) {
                handler(null, entry);
                return null;
              }
              R.push(entry);
            }
          }
        }
        handler(null, R);
        return null;
      };
    })(this));
    return null;
  };

  TC = this;

  main = function() {
    return step(function*(resume) {
      var f, fc, fp, g;
      fc = function() {
        return FS.read('f');
      };
      fp = function() {
        return FS.write('f', (FS.read_json('a.json'))['x'] + 3);
      };
      f = function() {
        var R;
        if ((R = fc()) != null) {
          return R;
        }
        return fp();
      };
      g = TC.new_cache();
      TC.register(g, 'f.coffee', 'f.js', "coffee -o lib -c src");
      TC.register(g, 'f.js', 'a.json', '???');
      TC.register(g, 'a.json', 'f.js', '???');
      TC.register(g, 'foo', 'bar', 'frobulate');
      TC.register(g, 'baz', null, 'bazify');
      FS.write('f.coffee', "### some CS here ###");
      FS.write('f.js', "/* some JS here */");
      FS.write('foo', "BLAH");
      FS.write('baz', "BLAH");
      warn('################# @1 #############################');
      FS.write_json('a.json', {
        x: 42
      });
      info(f());
      urge('cache:\n' + rpr(FS.cache));
      help("boxed trend:", (yield TC.fetch_boxed_trend(g, resume)));
      warn((yield TC.find_first_fault(g, resume)));
      warn('################# @2 #############################');
      FS.write('f.coffee', "### some modified CS here ###");
      FS.write_json('a.json', {
        x: 108
      });
      info(f());
      urge('cache:\n' + rpr(FS.cache));
      warn((yield TC.find_first_fault(g, resume)));
      urge((yield TC.find_faults(g, resume)));
      return null;
    });
  };

  if (module.parent == null) {
    main();

    /*
    URL = require 'url'
    debug URL.parse 'https://nodejs.org/api/url.html#url_url_format_urlobject'
    nfo =
      protocol: 'file:',
      slashes: true,
      pathname: '/home/url.json',
    
    help URL.format nfo
    help URL.format protocol: 'cache', slashes: no, pathname: 'foo'
    help URL.format protocol: 'file', slashes: yes, pathname: 'foo'
     */
  }

}).call(this);

//# sourceMappingURL=demo.js.map
